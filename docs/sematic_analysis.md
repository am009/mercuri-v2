
### Scope

scope是树形的结构，通过enter和leave进入和离开新的作用域。

### Module

目前module好像就只是用来保存builtin functions的。

### 数组与Eval

由于编译器Eval只是常量表达式的要求，因此只需要关心常量表达式这部分。而由于这里面可能涉及到常量变量，需要查符号表，因此放在语义分析阶段来做。比如dimensions，生成时仅生成`List<Expr>`，语义分析的时候再生成List<Integer>。Const变量的init

Decl可能是常量也可能不是，可能有初始化值也可能没有。当Decl是常量时，才需要将初始化值在编译器计算出来，同时考虑Decl是数组的情况。常量数组在声明的时候，语义分析就整理Decl里的initVal为evaledVal。后面常量表达式中可能访问到变量的是LValExpr。这个表达式可能是直接访问普通的int float常量，也可能是根据下标访问Const数组。由于之前定义数组的时候已经处理好了，所以可以直接取下标。

### 数组初始化解析

具体实现的时候，由于数组初始化也可能不是Const变量，甚至数组某些成员的初始化表达式里不是ConstExpr。因此先对树状结构用下面的算法做对齐和填充，如果是Const再去eval。

https://pku-minic.github.io/online-doc/#/lv9-array/ 这里有一些讲解

具体算法为：(参考https://en.cppreference.com/w/c/language/array_initialization#Nested_arrays )
依次递归子类型，递归的同时解包一层大括号，直到递归到单维数组的情况。如果大括号不够，就提前进入展开模式。
最后递归到仅单维数组。此时的解析模式根据下一个符号是否是大括号决定（即下一个元素是原语类型的还是数组类型的）
- 如果是大括号，则仅使用这个大括号内的东西递归解决子问题
- 如果不是大括号，则认为是展开模式，在当前层次依次取当前子问题需要的元素数量，直接解决当前子问题。

例如：`int a[3][2][2] = {1,6, {2, 3}, 4, 5};`设递归函数为F，参数有：当前需要解析的数组维度，当前的解析队列
- `F(a[3][2][2], [{1,6,{2,3},4,5}])`，首先解包大括号得到`[1,6,{2,3},4,5]` 此时需要对解析队列依次调用`F(a[2][2], queue)`三次，然后组合成`a[3][2][2]`
    - 第一轮`F(a[2][2], [1,6,{2,3},4,5])`，解包大括号失败，直接递归调用子问题
        - `F(a[2], [1,6,{2,3},4,5])` 发现目前第一个元素不是大括号，使用展开模式，解析返回 `{1,6}`
        - `F(a[2], [{2,3},4,5])` 发现第一个元素是大括号，仅使用大括号内的元素分析，解析返回 `{2,3}`
    - 第二轮`F(a[2][2], [4,5])`，解包大括号失败，直接递归调用子问题
        - `F(a[2], [4,5])` 发现目前第一个元素不是大括号，使用展开模式，解析返回 `{4, 5}`
        - 后面的分析都返回全零，因此在这里省略。
得到结果 `int a[3][2][2] = {{{1,6}, {2,3}}, {{4,5},{}}, {{},{}}}`

其他例子1：
```
a[3][2] = {{1, 2},{3}, {5}};
a[3][2] = {1,2,{3},5} 
都初始化为
{{1, 2},{3,0}, {5,0}}
```

其他例子2:（以下例子都报 warning）（由于群里说用例是按照c99不报warning设计的，因此不会出现这种情况）
```
int a[3][2] = {1, {2, 3}, 4, 5};
初始化为 
{1, 2, 4, 5, 0, 0}

a[2] = {{1,2},3} 初始化为 {1,3}

int a[2] = {2,{{1,2},4,5},3}; 初始化为{2,1}
```

再例如 `int a[3][2][2] = {{1}, 6, {2, 3}, 4, 5};`
- `F(a[3][2][2], [{1}, 6, {2, 3}, 4, 5])` 对`{1}`解包大括号成功，第一个子问题仅使用`[1]`
    - `F(a[2][2], [1])` 得到 `{{1,0}, {0,0}}`
    此时队列为`[6, {2, 3}, 4, 5]`，解包失败，直接递归
    - `F(a[2][2], [6, {2, 3}, 4, 5])` 解包失败，直接递归
        - `F(a[2], [6, {2, 3}, 4, 5])` 依次取两个数，第一个6没问题，第二个取到了`{2, 3}`，但是当前只需要数字啊，依次递归取第一个元素得到2。最终结果为`{6,2}`(这意味着这里的{2,3}无论变得多复杂，都只会取到2，比如`int a[3][2][2] = {{1},6, {{2,3}, 3,4}, 4, 5};`结果相同)
        - `F(a[2], [4, 5])` 得到 `{4, 5}`。之后的解析都是全零
最终结果得到 `{{{1,0},{0,0}}, {{6,2},{4,5}}}, ...`

### 类型转换节点

需要插入类型转换节点的地方：
- 函数参数
- 函数返回值
- binary op两边类型不一致
- decl的initial value

关于condition，还是让各种Logic expr返回int32，仅在需要做逻辑判断的时候通过not eq 0转为i1。部分运算符仅会出现在条件判断中的意思是，条件判断表达式的能力其实大于普通表达式的，可以包含任何表达式。因为95_float.sy中出现了if(x)这种用法。。。这种用法意味着，并不存在一种幻觉，即条件判断表达式最后总得用一个特殊的逻辑判断，类似于转一下转成boolean。所以只能说不如直接支持条件表达式出现在外面。。。反而更简单。


